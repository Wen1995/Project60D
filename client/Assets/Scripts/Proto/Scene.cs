// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=null.  DO NOT EDIT!
#pragma warning disable
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace com.game.framework.protocol {
  
  public static partial class Scene {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    #endregion
    #region Extensions
    internal static readonly object Descriptor;
    static Scene() {
      Descriptor = null;
    }
    #endregion
    
  }
  #region Messages
  public sealed partial class TCSGetSceneInfo : pb::GeneratedMessageLite<TCSGetSceneInfo, TCSGetSceneInfo.Builder> {
    private TCSGetSceneInfo() { }
    private static readonly TCSGetSceneInfo defaultInstance = new TCSGetSceneInfo().MakeReadOnly();
    private static readonly string[] _tCSGetSceneInfoFieldNames = new string[] {  };
    private static readonly uint[] _tCSGetSceneInfoFieldTags = new uint[] {  };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetSceneInfo DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TCSGetSceneInfo DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TCSGetSceneInfo ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tCSGetSceneInfoFieldNames;
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TCSGetSceneInfo other = obj as TCSGetSceneInfo;
      if (other == null) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetSceneInfo ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetSceneInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetSceneInfo ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetSceneInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetSceneInfo ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetSceneInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetSceneInfo ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetSceneInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetSceneInfo ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetSceneInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TCSGetSceneInfo MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TCSGetSceneInfo prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TCSGetSceneInfo, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TCSGetSceneInfo cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TCSGetSceneInfo result;
      
      private TCSGetSceneInfo PrepareBuilder() {
        if (resultIsReadOnly) {
          TCSGetSceneInfo original = result;
          result = new TCSGetSceneInfo();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TCSGetSceneInfo MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TCSGetSceneInfo DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TCSGetSceneInfo.DefaultInstance; }
      }
      
      public override TCSGetSceneInfo BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TCSGetSceneInfo) {
          return MergeFrom((TCSGetSceneInfo) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TCSGetSceneInfo other) {
        if (other == global::com.game.framework.protocol.TCSGetSceneInfo.DefaultInstance) return this;
        PrepareBuilder();
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tCSGetSceneInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tCSGetSceneInfoFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        return this;
      }
      
    }
    static TCSGetSceneInfo() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TSCGetSceneInfo : pb::GeneratedMessageLite<TSCGetSceneInfo, TSCGetSceneInfo.Builder> {
    private TSCGetSceneInfo() { }
    private static readonly TSCGetSceneInfo defaultInstance = new TSCGetSceneInfo().MakeReadOnly();
    private static readonly string[] _tSCGetSceneInfoFieldNames = new string[] { "buildingInfos", "totalContribution" };
    private static readonly uint[] _tSCGetSceneInfoFieldTags = new uint[] { 10, 16 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetSceneInfo DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TSCGetSceneInfo DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TSCGetSceneInfo ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingInfosFieldNumber = 1;
    private pbc::PopsicleList<global::com.game.framework.protocol.BuildingInfo> buildingInfos_ = new pbc::PopsicleList<global::com.game.framework.protocol.BuildingInfo>();
    public scg::IList<global::com.game.framework.protocol.BuildingInfo> BuildingInfosList {
      get { return buildingInfos_; }
    }
    public int BuildingInfosCount {
      get { return buildingInfos_.Count; }
    }
    public global::com.game.framework.protocol.BuildingInfo GetBuildingInfos(int index) {
      return buildingInfos_[index];
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int TotalContributionFieldNumber = 2;
    private bool hasTotalContribution;
    private int totalContribution_;
    public bool HasTotalContribution {
      get { return hasTotalContribution; }
    }
    public int TotalContribution {
      get { return totalContribution_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tSCGetSceneInfoFieldNames;
      if (buildingInfos_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], buildingInfos_);
      }
      if (hasTotalContribution) {
        output.WriteInt32(2, field_names[1], TotalContribution);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::com.game.framework.protocol.BuildingInfo element in BuildingInfosList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        if (hasTotalContribution) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, TotalContribution);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      foreach(global::com.game.framework.protocol.BuildingInfo i in buildingInfos_)
        hash ^= i.GetHashCode();
      if (hasTotalContribution) hash ^= totalContribution_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TSCGetSceneInfo other = obj as TSCGetSceneInfo;
      if (other == null) return false;
      if(buildingInfos_.Count != other.buildingInfos_.Count) return false;
      for(int ix=0; ix < buildingInfos_.Count; ix++)
        if(!buildingInfos_[ix].Equals(other.buildingInfos_[ix])) return false;
      if (hasTotalContribution != other.hasTotalContribution || (hasTotalContribution && !totalContribution_.Equals(other.totalContribution_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetSceneInfo ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetSceneInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetSceneInfo ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetSceneInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetSceneInfo ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetSceneInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetSceneInfo ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetSceneInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetSceneInfo ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetSceneInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TSCGetSceneInfo MakeReadOnly() {
      buildingInfos_.MakeReadOnly();
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TSCGetSceneInfo prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TSCGetSceneInfo, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TSCGetSceneInfo cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TSCGetSceneInfo result;
      
      private TSCGetSceneInfo PrepareBuilder() {
        if (resultIsReadOnly) {
          TSCGetSceneInfo original = result;
          result = new TSCGetSceneInfo();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TSCGetSceneInfo MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TSCGetSceneInfo DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TSCGetSceneInfo.DefaultInstance; }
      }
      
      public override TSCGetSceneInfo BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TSCGetSceneInfo) {
          return MergeFrom((TSCGetSceneInfo) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TSCGetSceneInfo other) {
        if (other == global::com.game.framework.protocol.TSCGetSceneInfo.DefaultInstance) return this;
        PrepareBuilder();
        if (other.buildingInfos_.Count != 0) {
          result.buildingInfos_.Add(other.buildingInfos_);
        }
        if (other.HasTotalContribution) {
          TotalContribution = other.TotalContribution;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tSCGetSceneInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tSCGetSceneInfoFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.buildingInfos_, global::com.game.framework.protocol.BuildingInfo.DefaultInstance, extensionRegistry);
              break;
            }
            case 16: {
              result.hasTotalContribution = input.ReadInt32(ref result.totalContribution_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public pbc::IPopsicleList<global::com.game.framework.protocol.BuildingInfo> BuildingInfosList {
        get { return PrepareBuilder().buildingInfos_; }
      }
      public int BuildingInfosCount {
        get { return result.BuildingInfosCount; }
      }
      public global::com.game.framework.protocol.BuildingInfo GetBuildingInfos(int index) {
        return result.GetBuildingInfos(index);
      }
      public Builder SetBuildingInfos(int index, global::com.game.framework.protocol.BuildingInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.buildingInfos_[index] = value;
        return this;
      }
      public Builder SetBuildingInfos(int index, global::com.game.framework.protocol.BuildingInfo.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.buildingInfos_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddBuildingInfos(global::com.game.framework.protocol.BuildingInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.buildingInfos_.Add(value);
        return this;
      }
      public Builder AddBuildingInfos(global::com.game.framework.protocol.BuildingInfo.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.buildingInfos_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeBuildingInfos(scg::IEnumerable<global::com.game.framework.protocol.BuildingInfo> values) {
        PrepareBuilder();
        result.buildingInfos_.Add(values);
        return this;
      }
      public Builder ClearBuildingInfos() {
        PrepareBuilder();
        result.buildingInfos_.Clear();
        return this;
      }
      
      public bool HasTotalContribution {
        get { return result.hasTotalContribution; }
      }
      public int TotalContribution {
        get { return result.TotalContribution; }
        set { SetTotalContribution(value); }
      }
      public Builder SetTotalContribution(int value) {
        PrepareBuilder();
        result.hasTotalContribution = true;
        result.totalContribution_ = value;
        return this;
      }
      public Builder ClearTotalContribution() {
        PrepareBuilder();
        result.hasTotalContribution = false;
        result.totalContribution_ = 0;
        return this;
      }
    }
    static TSCGetSceneInfo() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TCSGetBuildingInfo : pb::GeneratedMessageLite<TCSGetBuildingInfo, TCSGetBuildingInfo.Builder> {
    private TCSGetBuildingInfo() { }
    private static readonly TCSGetBuildingInfo defaultInstance = new TCSGetBuildingInfo().MakeReadOnly();
    private static readonly string[] _tCSGetBuildingInfoFieldNames = new string[] { "buildingId" };
    private static readonly uint[] _tCSGetBuildingInfoFieldTags = new uint[] { 8 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetBuildingInfo DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TCSGetBuildingInfo DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TCSGetBuildingInfo ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tCSGetBuildingInfoFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TCSGetBuildingInfo other = obj as TCSGetBuildingInfo;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetBuildingInfo ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetBuildingInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetBuildingInfo ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetBuildingInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetBuildingInfo ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetBuildingInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetBuildingInfo ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetBuildingInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetBuildingInfo ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSGetBuildingInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TCSGetBuildingInfo MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TCSGetBuildingInfo prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TCSGetBuildingInfo, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TCSGetBuildingInfo cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TCSGetBuildingInfo result;
      
      private TCSGetBuildingInfo PrepareBuilder() {
        if (resultIsReadOnly) {
          TCSGetBuildingInfo original = result;
          result = new TCSGetBuildingInfo();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TCSGetBuildingInfo MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TCSGetBuildingInfo DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TCSGetBuildingInfo.DefaultInstance; }
      }
      
      public override TCSGetBuildingInfo BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TCSGetBuildingInfo) {
          return MergeFrom((TCSGetBuildingInfo) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TCSGetBuildingInfo other) {
        if (other == global::com.game.framework.protocol.TCSGetBuildingInfo.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tCSGetBuildingInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tCSGetBuildingInfoFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
    }
    static TCSGetBuildingInfo() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TSCGetBuildingInfo : pb::GeneratedMessageLite<TSCGetBuildingInfo, TSCGetBuildingInfo.Builder> {
    private TSCGetBuildingInfo() { }
    private static readonly TSCGetBuildingInfo defaultInstance = new TSCGetBuildingInfo().MakeReadOnly();
    private static readonly string[] _tSCGetBuildingInfoFieldNames = new string[] { "buildingInfo" };
    private static readonly uint[] _tSCGetBuildingInfoFieldTags = new uint[] { 10 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetBuildingInfo DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TSCGetBuildingInfo DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TSCGetBuildingInfo ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingInfoFieldNumber = 1;
    private bool hasBuildingInfo;
    private global::com.game.framework.protocol.BuildingInfo buildingInfo_;
    public bool HasBuildingInfo {
      get { return hasBuildingInfo; }
    }
    public global::com.game.framework.protocol.BuildingInfo BuildingInfo {
      get { return buildingInfo_ ?? global::com.game.framework.protocol.BuildingInfo.DefaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tSCGetBuildingInfoFieldNames;
      if (hasBuildingInfo) {
        output.WriteMessage(1, field_names[0], BuildingInfo);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingInfo) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, BuildingInfo);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingInfo) hash ^= buildingInfo_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TSCGetBuildingInfo other = obj as TSCGetBuildingInfo;
      if (other == null) return false;
      if (hasBuildingInfo != other.hasBuildingInfo || (hasBuildingInfo && !buildingInfo_.Equals(other.buildingInfo_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetBuildingInfo ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetBuildingInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetBuildingInfo ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetBuildingInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetBuildingInfo ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetBuildingInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetBuildingInfo ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetBuildingInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetBuildingInfo ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCGetBuildingInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TSCGetBuildingInfo MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TSCGetBuildingInfo prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TSCGetBuildingInfo, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TSCGetBuildingInfo cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TSCGetBuildingInfo result;
      
      private TSCGetBuildingInfo PrepareBuilder() {
        if (resultIsReadOnly) {
          TSCGetBuildingInfo original = result;
          result = new TSCGetBuildingInfo();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TSCGetBuildingInfo MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TSCGetBuildingInfo DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TSCGetBuildingInfo.DefaultInstance; }
      }
      
      public override TSCGetBuildingInfo BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TSCGetBuildingInfo) {
          return MergeFrom((TSCGetBuildingInfo) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TSCGetBuildingInfo other) {
        if (other == global::com.game.framework.protocol.TSCGetBuildingInfo.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingInfo) {
          MergeBuildingInfo(other.BuildingInfo);
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tSCGetBuildingInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tSCGetBuildingInfoFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::com.game.framework.protocol.BuildingInfo.Builder subBuilder = global::com.game.framework.protocol.BuildingInfo.CreateBuilder();
              if (result.hasBuildingInfo) {
                subBuilder.MergeFrom(BuildingInfo);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              BuildingInfo = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingInfo {
       get { return result.hasBuildingInfo; }
      }
      public global::com.game.framework.protocol.BuildingInfo BuildingInfo {
        get { return result.BuildingInfo; }
        set { SetBuildingInfo(value); }
      }
      public Builder SetBuildingInfo(global::com.game.framework.protocol.BuildingInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBuildingInfo = true;
        result.buildingInfo_ = value;
        return this;
      }
      public Builder SetBuildingInfo(global::com.game.framework.protocol.BuildingInfo.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasBuildingInfo = true;
        result.buildingInfo_ = builderForValue.Build();
        return this;
      }
      public Builder MergeBuildingInfo(global::com.game.framework.protocol.BuildingInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasBuildingInfo &&
            result.buildingInfo_ != global::com.game.framework.protocol.BuildingInfo.DefaultInstance) {
            result.buildingInfo_ = global::com.game.framework.protocol.BuildingInfo.CreateBuilder(result.buildingInfo_).MergeFrom(value).BuildPartial();
        } else {
          result.buildingInfo_ = value;
        }
        result.hasBuildingInfo = true;
        return this;
      }
      public Builder ClearBuildingInfo() {
        PrepareBuilder();
        result.hasBuildingInfo = false;
        result.buildingInfo_ = null;
        return this;
      }
    }
    static TSCGetBuildingInfo() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class BuildingInfo : pb::GeneratedMessageLite<BuildingInfo, BuildingInfo.Builder> {
    private BuildingInfo() { }
    private static readonly BuildingInfo defaultInstance = new BuildingInfo().MakeReadOnly();
    private static readonly string[] _buildingInfoFieldNames = new string[] { "buildingId", "configId", "number", "processFinishTime", "processUid", "upgradeFinishTime", "upgradeUid" };
    private static readonly uint[] _buildingInfoFieldTags = new uint[] { 8, 16, 56, 40, 48, 24, 32 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static BuildingInfo DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override BuildingInfo DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override BuildingInfo ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int ConfigIdFieldNumber = 2;
    private bool hasConfigId;
    private int configId_;
    public bool HasConfigId {
      get { return hasConfigId; }
    }
    public int ConfigId {
      get { return configId_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int UpgradeFinishTimeFieldNumber = 3;
    private bool hasUpgradeFinishTime;
    private long upgradeFinishTime_;
    public bool HasUpgradeFinishTime {
      get { return hasUpgradeFinishTime; }
    }
    public long UpgradeFinishTime {
      get { return upgradeFinishTime_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int UpgradeUidFieldNumber = 4;
    private bool hasUpgradeUid;
    private long upgradeUid_;
    public bool HasUpgradeUid {
      get { return hasUpgradeUid; }
    }
    public long UpgradeUid {
      get { return upgradeUid_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int ProcessFinishTimeFieldNumber = 5;
    private bool hasProcessFinishTime;
    private long processFinishTime_;
    public bool HasProcessFinishTime {
      get { return hasProcessFinishTime; }
    }
    public long ProcessFinishTime {
      get { return processFinishTime_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int ProcessUidFieldNumber = 6;
    private bool hasProcessUid;
    private long processUid_;
    public bool HasProcessUid {
      get { return hasProcessUid; }
    }
    public long ProcessUid {
      get { return processUid_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int NumberFieldNumber = 7;
    private bool hasNumber;
    private int number_;
    public bool HasNumber {
      get { return hasNumber; }
    }
    public int Number {
      get { return number_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _buildingInfoFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
      if (hasConfigId) {
        output.WriteInt32(2, field_names[1], ConfigId);
      }
      if (hasUpgradeFinishTime) {
        output.WriteInt64(3, field_names[5], UpgradeFinishTime);
      }
      if (hasUpgradeUid) {
        output.WriteInt64(4, field_names[6], UpgradeUid);
      }
      if (hasProcessFinishTime) {
        output.WriteInt64(5, field_names[3], ProcessFinishTime);
      }
      if (hasProcessUid) {
        output.WriteInt64(6, field_names[4], ProcessUid);
      }
      if (hasNumber) {
        output.WriteInt32(7, field_names[2], Number);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        if (hasConfigId) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, ConfigId);
        }
        if (hasUpgradeFinishTime) {
          size += pb::CodedOutputStream.ComputeInt64Size(3, UpgradeFinishTime);
        }
        if (hasUpgradeUid) {
          size += pb::CodedOutputStream.ComputeInt64Size(4, UpgradeUid);
        }
        if (hasProcessFinishTime) {
          size += pb::CodedOutputStream.ComputeInt64Size(5, ProcessFinishTime);
        }
        if (hasProcessUid) {
          size += pb::CodedOutputStream.ComputeInt64Size(6, ProcessUid);
        }
        if (hasNumber) {
          size += pb::CodedOutputStream.ComputeInt32Size(7, Number);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      if (hasConfigId) hash ^= configId_.GetHashCode();
      if (hasUpgradeFinishTime) hash ^= upgradeFinishTime_.GetHashCode();
      if (hasUpgradeUid) hash ^= upgradeUid_.GetHashCode();
      if (hasProcessFinishTime) hash ^= processFinishTime_.GetHashCode();
      if (hasProcessUid) hash ^= processUid_.GetHashCode();
      if (hasNumber) hash ^= number_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      BuildingInfo other = obj as BuildingInfo;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      if (hasConfigId != other.hasConfigId || (hasConfigId && !configId_.Equals(other.configId_))) return false;
      if (hasUpgradeFinishTime != other.hasUpgradeFinishTime || (hasUpgradeFinishTime && !upgradeFinishTime_.Equals(other.upgradeFinishTime_))) return false;
      if (hasUpgradeUid != other.hasUpgradeUid || (hasUpgradeUid && !upgradeUid_.Equals(other.upgradeUid_))) return false;
      if (hasProcessFinishTime != other.hasProcessFinishTime || (hasProcessFinishTime && !processFinishTime_.Equals(other.processFinishTime_))) return false;
      if (hasProcessUid != other.hasProcessUid || (hasProcessUid && !processUid_.Equals(other.processUid_))) return false;
      if (hasNumber != other.hasNumber || (hasNumber && !number_.Equals(other.number_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static BuildingInfo ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static BuildingInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static BuildingInfo ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static BuildingInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static BuildingInfo ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static BuildingInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static BuildingInfo ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static BuildingInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static BuildingInfo ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static BuildingInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private BuildingInfo MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(BuildingInfo prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<BuildingInfo, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(BuildingInfo cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private BuildingInfo result;
      
      private BuildingInfo PrepareBuilder() {
        if (resultIsReadOnly) {
          BuildingInfo original = result;
          result = new BuildingInfo();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override BuildingInfo MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override BuildingInfo DefaultInstanceForType {
        get { return global::com.game.framework.protocol.BuildingInfo.DefaultInstance; }
      }
      
      public override BuildingInfo BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is BuildingInfo) {
          return MergeFrom((BuildingInfo) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(BuildingInfo other) {
        if (other == global::com.game.framework.protocol.BuildingInfo.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        if (other.HasConfigId) {
          ConfigId = other.ConfigId;
        }
        if (other.HasUpgradeFinishTime) {
          UpgradeFinishTime = other.UpgradeFinishTime;
        }
        if (other.HasUpgradeUid) {
          UpgradeUid = other.UpgradeUid;
        }
        if (other.HasProcessFinishTime) {
          ProcessFinishTime = other.ProcessFinishTime;
        }
        if (other.HasProcessUid) {
          ProcessUid = other.ProcessUid;
        }
        if (other.HasNumber) {
          Number = other.Number;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_buildingInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _buildingInfoFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
            case 16: {
              result.hasConfigId = input.ReadInt32(ref result.configId_);
              break;
            }
            case 24: {
              result.hasUpgradeFinishTime = input.ReadInt64(ref result.upgradeFinishTime_);
              break;
            }
            case 32: {
              result.hasUpgradeUid = input.ReadInt64(ref result.upgradeUid_);
              break;
            }
            case 40: {
              result.hasProcessFinishTime = input.ReadInt64(ref result.processFinishTime_);
              break;
            }
            case 48: {
              result.hasProcessUid = input.ReadInt64(ref result.processUid_);
              break;
            }
            case 56: {
              result.hasNumber = input.ReadInt32(ref result.number_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
      
      public bool HasConfigId {
        get { return result.hasConfigId; }
      }
      public int ConfigId {
        get { return result.ConfigId; }
        set { SetConfigId(value); }
      }
      public Builder SetConfigId(int value) {
        PrepareBuilder();
        result.hasConfigId = true;
        result.configId_ = value;
        return this;
      }
      public Builder ClearConfigId() {
        PrepareBuilder();
        result.hasConfigId = false;
        result.configId_ = 0;
        return this;
      }
      
      public bool HasUpgradeFinishTime {
        get { return result.hasUpgradeFinishTime; }
      }
      public long UpgradeFinishTime {
        get { return result.UpgradeFinishTime; }
        set { SetUpgradeFinishTime(value); }
      }
      public Builder SetUpgradeFinishTime(long value) {
        PrepareBuilder();
        result.hasUpgradeFinishTime = true;
        result.upgradeFinishTime_ = value;
        return this;
      }
      public Builder ClearUpgradeFinishTime() {
        PrepareBuilder();
        result.hasUpgradeFinishTime = false;
        result.upgradeFinishTime_ = 0L;
        return this;
      }
      
      public bool HasUpgradeUid {
        get { return result.hasUpgradeUid; }
      }
      public long UpgradeUid {
        get { return result.UpgradeUid; }
        set { SetUpgradeUid(value); }
      }
      public Builder SetUpgradeUid(long value) {
        PrepareBuilder();
        result.hasUpgradeUid = true;
        result.upgradeUid_ = value;
        return this;
      }
      public Builder ClearUpgradeUid() {
        PrepareBuilder();
        result.hasUpgradeUid = false;
        result.upgradeUid_ = 0L;
        return this;
      }
      
      public bool HasProcessFinishTime {
        get { return result.hasProcessFinishTime; }
      }
      public long ProcessFinishTime {
        get { return result.ProcessFinishTime; }
        set { SetProcessFinishTime(value); }
      }
      public Builder SetProcessFinishTime(long value) {
        PrepareBuilder();
        result.hasProcessFinishTime = true;
        result.processFinishTime_ = value;
        return this;
      }
      public Builder ClearProcessFinishTime() {
        PrepareBuilder();
        result.hasProcessFinishTime = false;
        result.processFinishTime_ = 0L;
        return this;
      }
      
      public bool HasProcessUid {
        get { return result.hasProcessUid; }
      }
      public long ProcessUid {
        get { return result.ProcessUid; }
        set { SetProcessUid(value); }
      }
      public Builder SetProcessUid(long value) {
        PrepareBuilder();
        result.hasProcessUid = true;
        result.processUid_ = value;
        return this;
      }
      public Builder ClearProcessUid() {
        PrepareBuilder();
        result.hasProcessUid = false;
        result.processUid_ = 0L;
        return this;
      }
      
      public bool HasNumber {
        get { return result.hasNumber; }
      }
      public int Number {
        get { return result.Number; }
        set { SetNumber(value); }
      }
      public Builder SetNumber(int value) {
        PrepareBuilder();
        result.hasNumber = true;
        result.number_ = value;
        return this;
      }
      public Builder ClearNumber() {
        PrepareBuilder();
        result.hasNumber = false;
        result.number_ = 0;
        return this;
      }
    }
    static BuildingInfo() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TCSUpgrade : pb::GeneratedMessageLite<TCSUpgrade, TCSUpgrade.Builder> {
    private TCSUpgrade() { }
    private static readonly TCSUpgrade defaultInstance = new TCSUpgrade().MakeReadOnly();
    private static readonly string[] _tCSUpgradeFieldNames = new string[] { "buildingId" };
    private static readonly uint[] _tCSUpgradeFieldTags = new uint[] { 8 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUpgrade DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TCSUpgrade DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TCSUpgrade ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tCSUpgradeFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TCSUpgrade other = obj as TCSUpgrade;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUpgrade ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUpgrade ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUpgrade ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUpgrade ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUpgrade ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUpgrade ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUpgrade ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUpgrade ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUpgrade ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUpgrade ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TCSUpgrade MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TCSUpgrade prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TCSUpgrade, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TCSUpgrade cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TCSUpgrade result;
      
      private TCSUpgrade PrepareBuilder() {
        if (resultIsReadOnly) {
          TCSUpgrade original = result;
          result = new TCSUpgrade();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TCSUpgrade MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TCSUpgrade DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TCSUpgrade.DefaultInstance; }
      }
      
      public override TCSUpgrade BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TCSUpgrade) {
          return MergeFrom((TCSUpgrade) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TCSUpgrade other) {
        if (other == global::com.game.framework.protocol.TCSUpgrade.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tCSUpgradeFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tCSUpgradeFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
    }
    static TCSUpgrade() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TSCUpgrade : pb::GeneratedMessageLite<TSCUpgrade, TSCUpgrade.Builder> {
    private TSCUpgrade() { }
    private static readonly TSCUpgrade defaultInstance = new TSCUpgrade().MakeReadOnly();
    private static readonly string[] _tSCUpgradeFieldNames = new string[] { "buildingId", "finishTime", "isGroup", "isProduction", "isResource", "isState" };
    private static readonly uint[] _tSCUpgradeFieldTags = new uint[] { 48, 40, 16, 32, 24, 8 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUpgrade DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TSCUpgrade DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TSCUpgrade ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int IsStateFieldNumber = 1;
    private bool hasIsState;
    private bool isState_;
    public bool HasIsState {
      get { return hasIsState; }
    }
    public bool IsState {
      get { return isState_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int IsGroupFieldNumber = 2;
    private bool hasIsGroup;
    private bool isGroup_;
    public bool HasIsGroup {
      get { return hasIsGroup; }
    }
    public bool IsGroup {
      get { return isGroup_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int IsResourceFieldNumber = 3;
    private bool hasIsResource;
    private bool isResource_;
    public bool HasIsResource {
      get { return hasIsResource; }
    }
    public bool IsResource {
      get { return isResource_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int IsProductionFieldNumber = 4;
    private bool hasIsProduction;
    private bool isProduction_;
    public bool HasIsProduction {
      get { return hasIsProduction; }
    }
    public bool IsProduction {
      get { return isProduction_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int FinishTimeFieldNumber = 5;
    private bool hasFinishTime;
    private long finishTime_;
    public bool HasFinishTime {
      get { return hasFinishTime; }
    }
    public long FinishTime {
      get { return finishTime_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 6;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tSCUpgradeFieldNames;
      if (hasIsState) {
        output.WriteBool(1, field_names[5], IsState);
      }
      if (hasIsGroup) {
        output.WriteBool(2, field_names[2], IsGroup);
      }
      if (hasIsResource) {
        output.WriteBool(3, field_names[4], IsResource);
      }
      if (hasIsProduction) {
        output.WriteBool(4, field_names[3], IsProduction);
      }
      if (hasFinishTime) {
        output.WriteInt64(5, field_names[1], FinishTime);
      }
      if (hasBuildingId) {
        output.WriteInt64(6, field_names[0], BuildingId);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasIsState) {
          size += pb::CodedOutputStream.ComputeBoolSize(1, IsState);
        }
        if (hasIsGroup) {
          size += pb::CodedOutputStream.ComputeBoolSize(2, IsGroup);
        }
        if (hasIsResource) {
          size += pb::CodedOutputStream.ComputeBoolSize(3, IsResource);
        }
        if (hasIsProduction) {
          size += pb::CodedOutputStream.ComputeBoolSize(4, IsProduction);
        }
        if (hasFinishTime) {
          size += pb::CodedOutputStream.ComputeInt64Size(5, FinishTime);
        }
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(6, BuildingId);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasIsState) hash ^= isState_.GetHashCode();
      if (hasIsGroup) hash ^= isGroup_.GetHashCode();
      if (hasIsResource) hash ^= isResource_.GetHashCode();
      if (hasIsProduction) hash ^= isProduction_.GetHashCode();
      if (hasFinishTime) hash ^= finishTime_.GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TSCUpgrade other = obj as TSCUpgrade;
      if (other == null) return false;
      if (hasIsState != other.hasIsState || (hasIsState && !isState_.Equals(other.isState_))) return false;
      if (hasIsGroup != other.hasIsGroup || (hasIsGroup && !isGroup_.Equals(other.isGroup_))) return false;
      if (hasIsResource != other.hasIsResource || (hasIsResource && !isResource_.Equals(other.isResource_))) return false;
      if (hasIsProduction != other.hasIsProduction || (hasIsProduction && !isProduction_.Equals(other.isProduction_))) return false;
      if (hasFinishTime != other.hasFinishTime || (hasFinishTime && !finishTime_.Equals(other.finishTime_))) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUpgrade ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUpgrade ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUpgrade ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUpgrade ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUpgrade ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUpgrade ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUpgrade ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUpgrade ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUpgrade ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUpgrade ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TSCUpgrade MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TSCUpgrade prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TSCUpgrade, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TSCUpgrade cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TSCUpgrade result;
      
      private TSCUpgrade PrepareBuilder() {
        if (resultIsReadOnly) {
          TSCUpgrade original = result;
          result = new TSCUpgrade();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TSCUpgrade MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TSCUpgrade DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TSCUpgrade.DefaultInstance; }
      }
      
      public override TSCUpgrade BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TSCUpgrade) {
          return MergeFrom((TSCUpgrade) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TSCUpgrade other) {
        if (other == global::com.game.framework.protocol.TSCUpgrade.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasIsState) {
          IsState = other.IsState;
        }
        if (other.HasIsGroup) {
          IsGroup = other.IsGroup;
        }
        if (other.HasIsResource) {
          IsResource = other.IsResource;
        }
        if (other.HasIsProduction) {
          IsProduction = other.IsProduction;
        }
        if (other.HasFinishTime) {
          FinishTime = other.FinishTime;
        }
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tSCUpgradeFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tSCUpgradeFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasIsState = input.ReadBool(ref result.isState_);
              break;
            }
            case 16: {
              result.hasIsGroup = input.ReadBool(ref result.isGroup_);
              break;
            }
            case 24: {
              result.hasIsResource = input.ReadBool(ref result.isResource_);
              break;
            }
            case 32: {
              result.hasIsProduction = input.ReadBool(ref result.isProduction_);
              break;
            }
            case 40: {
              result.hasFinishTime = input.ReadInt64(ref result.finishTime_);
              break;
            }
            case 48: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasIsState {
        get { return result.hasIsState; }
      }
      public bool IsState {
        get { return result.IsState; }
        set { SetIsState(value); }
      }
      public Builder SetIsState(bool value) {
        PrepareBuilder();
        result.hasIsState = true;
        result.isState_ = value;
        return this;
      }
      public Builder ClearIsState() {
        PrepareBuilder();
        result.hasIsState = false;
        result.isState_ = false;
        return this;
      }
      
      public bool HasIsGroup {
        get { return result.hasIsGroup; }
      }
      public bool IsGroup {
        get { return result.IsGroup; }
        set { SetIsGroup(value); }
      }
      public Builder SetIsGroup(bool value) {
        PrepareBuilder();
        result.hasIsGroup = true;
        result.isGroup_ = value;
        return this;
      }
      public Builder ClearIsGroup() {
        PrepareBuilder();
        result.hasIsGroup = false;
        result.isGroup_ = false;
        return this;
      }
      
      public bool HasIsResource {
        get { return result.hasIsResource; }
      }
      public bool IsResource {
        get { return result.IsResource; }
        set { SetIsResource(value); }
      }
      public Builder SetIsResource(bool value) {
        PrepareBuilder();
        result.hasIsResource = true;
        result.isResource_ = value;
        return this;
      }
      public Builder ClearIsResource() {
        PrepareBuilder();
        result.hasIsResource = false;
        result.isResource_ = false;
        return this;
      }
      
      public bool HasIsProduction {
        get { return result.hasIsProduction; }
      }
      public bool IsProduction {
        get { return result.IsProduction; }
        set { SetIsProduction(value); }
      }
      public Builder SetIsProduction(bool value) {
        PrepareBuilder();
        result.hasIsProduction = true;
        result.isProduction_ = value;
        return this;
      }
      public Builder ClearIsProduction() {
        PrepareBuilder();
        result.hasIsProduction = false;
        result.isProduction_ = false;
        return this;
      }
      
      public bool HasFinishTime {
        get { return result.hasFinishTime; }
      }
      public long FinishTime {
        get { return result.FinishTime; }
        set { SetFinishTime(value); }
      }
      public Builder SetFinishTime(long value) {
        PrepareBuilder();
        result.hasFinishTime = true;
        result.finishTime_ = value;
        return this;
      }
      public Builder ClearFinishTime() {
        PrepareBuilder();
        result.hasFinishTime = false;
        result.finishTime_ = 0L;
        return this;
      }
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
    }
    static TSCUpgrade() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TCSFinishUpgrade : pb::GeneratedMessageLite<TCSFinishUpgrade, TCSFinishUpgrade.Builder> {
    private TCSFinishUpgrade() { }
    private static readonly TCSFinishUpgrade defaultInstance = new TCSFinishUpgrade().MakeReadOnly();
    private static readonly string[] _tCSFinishUpgradeFieldNames = new string[] { "buildingId" };
    private static readonly uint[] _tCSFinishUpgradeFieldTags = new uint[] { 8 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUpgrade DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TCSFinishUpgrade DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TCSFinishUpgrade ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tCSFinishUpgradeFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TCSFinishUpgrade other = obj as TCSFinishUpgrade;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUpgrade ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUpgrade ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUpgrade ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUpgrade ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUpgrade ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUpgrade ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUpgrade ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUpgrade ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUpgrade ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUpgrade ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TCSFinishUpgrade MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TCSFinishUpgrade prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TCSFinishUpgrade, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TCSFinishUpgrade cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TCSFinishUpgrade result;
      
      private TCSFinishUpgrade PrepareBuilder() {
        if (resultIsReadOnly) {
          TCSFinishUpgrade original = result;
          result = new TCSFinishUpgrade();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TCSFinishUpgrade MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TCSFinishUpgrade DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TCSFinishUpgrade.DefaultInstance; }
      }
      
      public override TCSFinishUpgrade BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TCSFinishUpgrade) {
          return MergeFrom((TCSFinishUpgrade) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TCSFinishUpgrade other) {
        if (other == global::com.game.framework.protocol.TCSFinishUpgrade.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tCSFinishUpgradeFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tCSFinishUpgradeFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
    }
    static TCSFinishUpgrade() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TSCFinishUpgrade : pb::GeneratedMessageLite<TSCFinishUpgrade, TSCFinishUpgrade.Builder> {
    private TSCFinishUpgrade() { }
    private static readonly TSCFinishUpgrade defaultInstance = new TSCFinishUpgrade().MakeReadOnly();
    private static readonly string[] _tSCFinishUpgradeFieldNames = new string[] { "buildingId" };
    private static readonly uint[] _tSCFinishUpgradeFieldTags = new uint[] { 8 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUpgrade DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TSCFinishUpgrade DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TSCFinishUpgrade ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tSCFinishUpgradeFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TSCFinishUpgrade other = obj as TSCFinishUpgrade;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUpgrade ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUpgrade ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUpgrade ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUpgrade ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUpgrade ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUpgrade ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUpgrade ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUpgrade ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUpgrade ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUpgrade ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TSCFinishUpgrade MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TSCFinishUpgrade prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TSCFinishUpgrade, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TSCFinishUpgrade cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TSCFinishUpgrade result;
      
      private TSCFinishUpgrade PrepareBuilder() {
        if (resultIsReadOnly) {
          TSCFinishUpgrade original = result;
          result = new TSCFinishUpgrade();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TSCFinishUpgrade MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TSCFinishUpgrade DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TSCFinishUpgrade.DefaultInstance; }
      }
      
      public override TSCFinishUpgrade BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TSCFinishUpgrade) {
          return MergeFrom((TSCFinishUpgrade) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TSCFinishUpgrade other) {
        if (other == global::com.game.framework.protocol.TSCFinishUpgrade.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tSCFinishUpgradeFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tSCFinishUpgradeFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
    }
    static TSCFinishUpgrade() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TCSUnlock : pb::GeneratedMessageLite<TCSUnlock, TCSUnlock.Builder> {
    private TCSUnlock() { }
    private static readonly TCSUnlock defaultInstance = new TCSUnlock().MakeReadOnly();
    private static readonly string[] _tCSUnlockFieldNames = new string[] { "configId" };
    private static readonly uint[] _tCSUnlockFieldTags = new uint[] { 8 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUnlock DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TCSUnlock DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TCSUnlock ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int ConfigIdFieldNumber = 1;
    private bool hasConfigId;
    private int configId_;
    public bool HasConfigId {
      get { return hasConfigId; }
    }
    public int ConfigId {
      get { return configId_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tCSUnlockFieldNames;
      if (hasConfigId) {
        output.WriteInt32(1, field_names[0], ConfigId);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasConfigId) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, ConfigId);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasConfigId) hash ^= configId_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TCSUnlock other = obj as TCSUnlock;
      if (other == null) return false;
      if (hasConfigId != other.hasConfigId || (hasConfigId && !configId_.Equals(other.configId_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUnlock ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUnlock ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUnlock ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUnlock ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUnlock ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUnlock ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUnlock ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUnlock ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUnlock ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSUnlock ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TCSUnlock MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TCSUnlock prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TCSUnlock, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TCSUnlock cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TCSUnlock result;
      
      private TCSUnlock PrepareBuilder() {
        if (resultIsReadOnly) {
          TCSUnlock original = result;
          result = new TCSUnlock();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TCSUnlock MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TCSUnlock DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TCSUnlock.DefaultInstance; }
      }
      
      public override TCSUnlock BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TCSUnlock) {
          return MergeFrom((TCSUnlock) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TCSUnlock other) {
        if (other == global::com.game.framework.protocol.TCSUnlock.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasConfigId) {
          ConfigId = other.ConfigId;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tCSUnlockFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tCSUnlockFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasConfigId = input.ReadInt32(ref result.configId_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasConfigId {
        get { return result.hasConfigId; }
      }
      public int ConfigId {
        get { return result.ConfigId; }
        set { SetConfigId(value); }
      }
      public Builder SetConfigId(int value) {
        PrepareBuilder();
        result.hasConfigId = true;
        result.configId_ = value;
        return this;
      }
      public Builder ClearConfigId() {
        PrepareBuilder();
        result.hasConfigId = false;
        result.configId_ = 0;
        return this;
      }
    }
    static TCSUnlock() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TSCUnlock : pb::GeneratedMessageLite<TSCUnlock, TSCUnlock.Builder> {
    private TSCUnlock() { }
    private static readonly TSCUnlock defaultInstance = new TSCUnlock().MakeReadOnly();
    private static readonly string[] _tSCUnlockFieldNames = new string[] { "buildingId", "finishTime", "isGroup", "isProduction", "isResource" };
    private static readonly uint[] _tSCUnlockFieldTags = new uint[] { 8, 40, 16, 32, 24 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUnlock DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TSCUnlock DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TSCUnlock ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int IsGroupFieldNumber = 2;
    private bool hasIsGroup;
    private bool isGroup_;
    public bool HasIsGroup {
      get { return hasIsGroup; }
    }
    public bool IsGroup {
      get { return isGroup_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int IsResourceFieldNumber = 3;
    private bool hasIsResource;
    private bool isResource_;
    public bool HasIsResource {
      get { return hasIsResource; }
    }
    public bool IsResource {
      get { return isResource_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int IsProductionFieldNumber = 4;
    private bool hasIsProduction;
    private bool isProduction_;
    public bool HasIsProduction {
      get { return hasIsProduction; }
    }
    public bool IsProduction {
      get { return isProduction_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int FinishTimeFieldNumber = 5;
    private bool hasFinishTime;
    private long finishTime_;
    public bool HasFinishTime {
      get { return hasFinishTime; }
    }
    public long FinishTime {
      get { return finishTime_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tSCUnlockFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
      if (hasIsGroup) {
        output.WriteBool(2, field_names[2], IsGroup);
      }
      if (hasIsResource) {
        output.WriteBool(3, field_names[4], IsResource);
      }
      if (hasIsProduction) {
        output.WriteBool(4, field_names[3], IsProduction);
      }
      if (hasFinishTime) {
        output.WriteInt64(5, field_names[1], FinishTime);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        if (hasIsGroup) {
          size += pb::CodedOutputStream.ComputeBoolSize(2, IsGroup);
        }
        if (hasIsResource) {
          size += pb::CodedOutputStream.ComputeBoolSize(3, IsResource);
        }
        if (hasIsProduction) {
          size += pb::CodedOutputStream.ComputeBoolSize(4, IsProduction);
        }
        if (hasFinishTime) {
          size += pb::CodedOutputStream.ComputeInt64Size(5, FinishTime);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      if (hasIsGroup) hash ^= isGroup_.GetHashCode();
      if (hasIsResource) hash ^= isResource_.GetHashCode();
      if (hasIsProduction) hash ^= isProduction_.GetHashCode();
      if (hasFinishTime) hash ^= finishTime_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TSCUnlock other = obj as TSCUnlock;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      if (hasIsGroup != other.hasIsGroup || (hasIsGroup && !isGroup_.Equals(other.isGroup_))) return false;
      if (hasIsResource != other.hasIsResource || (hasIsResource && !isResource_.Equals(other.isResource_))) return false;
      if (hasIsProduction != other.hasIsProduction || (hasIsProduction && !isProduction_.Equals(other.isProduction_))) return false;
      if (hasFinishTime != other.hasFinishTime || (hasFinishTime && !finishTime_.Equals(other.finishTime_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUnlock ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUnlock ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUnlock ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUnlock ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUnlock ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUnlock ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUnlock ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUnlock ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUnlock ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCUnlock ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TSCUnlock MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TSCUnlock prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TSCUnlock, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TSCUnlock cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TSCUnlock result;
      
      private TSCUnlock PrepareBuilder() {
        if (resultIsReadOnly) {
          TSCUnlock original = result;
          result = new TSCUnlock();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TSCUnlock MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TSCUnlock DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TSCUnlock.DefaultInstance; }
      }
      
      public override TSCUnlock BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TSCUnlock) {
          return MergeFrom((TSCUnlock) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TSCUnlock other) {
        if (other == global::com.game.framework.protocol.TSCUnlock.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        if (other.HasIsGroup) {
          IsGroup = other.IsGroup;
        }
        if (other.HasIsResource) {
          IsResource = other.IsResource;
        }
        if (other.HasIsProduction) {
          IsProduction = other.IsProduction;
        }
        if (other.HasFinishTime) {
          FinishTime = other.FinishTime;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tSCUnlockFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tSCUnlockFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
            case 16: {
              result.hasIsGroup = input.ReadBool(ref result.isGroup_);
              break;
            }
            case 24: {
              result.hasIsResource = input.ReadBool(ref result.isResource_);
              break;
            }
            case 32: {
              result.hasIsProduction = input.ReadBool(ref result.isProduction_);
              break;
            }
            case 40: {
              result.hasFinishTime = input.ReadInt64(ref result.finishTime_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
      
      public bool HasIsGroup {
        get { return result.hasIsGroup; }
      }
      public bool IsGroup {
        get { return result.IsGroup; }
        set { SetIsGroup(value); }
      }
      public Builder SetIsGroup(bool value) {
        PrepareBuilder();
        result.hasIsGroup = true;
        result.isGroup_ = value;
        return this;
      }
      public Builder ClearIsGroup() {
        PrepareBuilder();
        result.hasIsGroup = false;
        result.isGroup_ = false;
        return this;
      }
      
      public bool HasIsResource {
        get { return result.hasIsResource; }
      }
      public bool IsResource {
        get { return result.IsResource; }
        set { SetIsResource(value); }
      }
      public Builder SetIsResource(bool value) {
        PrepareBuilder();
        result.hasIsResource = true;
        result.isResource_ = value;
        return this;
      }
      public Builder ClearIsResource() {
        PrepareBuilder();
        result.hasIsResource = false;
        result.isResource_ = false;
        return this;
      }
      
      public bool HasIsProduction {
        get { return result.hasIsProduction; }
      }
      public bool IsProduction {
        get { return result.IsProduction; }
        set { SetIsProduction(value); }
      }
      public Builder SetIsProduction(bool value) {
        PrepareBuilder();
        result.hasIsProduction = true;
        result.isProduction_ = value;
        return this;
      }
      public Builder ClearIsProduction() {
        PrepareBuilder();
        result.hasIsProduction = false;
        result.isProduction_ = false;
        return this;
      }
      
      public bool HasFinishTime {
        get { return result.hasFinishTime; }
      }
      public long FinishTime {
        get { return result.FinishTime; }
        set { SetFinishTime(value); }
      }
      public Builder SetFinishTime(long value) {
        PrepareBuilder();
        result.hasFinishTime = true;
        result.finishTime_ = value;
        return this;
      }
      public Builder ClearFinishTime() {
        PrepareBuilder();
        result.hasFinishTime = false;
        result.finishTime_ = 0L;
        return this;
      }
    }
    static TSCUnlock() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TCSFinishUnlock : pb::GeneratedMessageLite<TCSFinishUnlock, TCSFinishUnlock.Builder> {
    private TCSFinishUnlock() { }
    private static readonly TCSFinishUnlock defaultInstance = new TCSFinishUnlock().MakeReadOnly();
    private static readonly string[] _tCSFinishUnlockFieldNames = new string[] { "buildingId" };
    private static readonly uint[] _tCSFinishUnlockFieldTags = new uint[] { 8 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUnlock DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TCSFinishUnlock DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TCSFinishUnlock ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tCSFinishUnlockFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TCSFinishUnlock other = obj as TCSFinishUnlock;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUnlock ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUnlock ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUnlock ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUnlock ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUnlock ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUnlock ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUnlock ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUnlock ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUnlock ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSFinishUnlock ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TCSFinishUnlock MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TCSFinishUnlock prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TCSFinishUnlock, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TCSFinishUnlock cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TCSFinishUnlock result;
      
      private TCSFinishUnlock PrepareBuilder() {
        if (resultIsReadOnly) {
          TCSFinishUnlock original = result;
          result = new TCSFinishUnlock();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TCSFinishUnlock MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TCSFinishUnlock DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TCSFinishUnlock.DefaultInstance; }
      }
      
      public override TCSFinishUnlock BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TCSFinishUnlock) {
          return MergeFrom((TCSFinishUnlock) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TCSFinishUnlock other) {
        if (other == global::com.game.framework.protocol.TCSFinishUnlock.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tCSFinishUnlockFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tCSFinishUnlockFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
    }
    static TCSFinishUnlock() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TSCFinishUnlock : pb::GeneratedMessageLite<TSCFinishUnlock, TSCFinishUnlock.Builder> {
    private TSCFinishUnlock() { }
    private static readonly TSCFinishUnlock defaultInstance = new TSCFinishUnlock().MakeReadOnly();
    private static readonly string[] _tSCFinishUnlockFieldNames = new string[] { "buildingId" };
    private static readonly uint[] _tSCFinishUnlockFieldTags = new uint[] { 8 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUnlock DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TSCFinishUnlock DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TSCFinishUnlock ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tSCFinishUnlockFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TSCFinishUnlock other = obj as TSCFinishUnlock;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUnlock ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUnlock ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUnlock ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUnlock ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUnlock ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUnlock ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUnlock ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUnlock ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUnlock ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCFinishUnlock ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TSCFinishUnlock MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TSCFinishUnlock prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TSCFinishUnlock, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TSCFinishUnlock cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TSCFinishUnlock result;
      
      private TSCFinishUnlock PrepareBuilder() {
        if (resultIsReadOnly) {
          TSCFinishUnlock original = result;
          result = new TSCFinishUnlock();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TSCFinishUnlock MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TSCFinishUnlock DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TSCFinishUnlock.DefaultInstance; }
      }
      
      public override TSCFinishUnlock BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TSCFinishUnlock) {
          return MergeFrom((TSCFinishUnlock) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TSCFinishUnlock other) {
        if (other == global::com.game.framework.protocol.TSCFinishUnlock.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tSCFinishUnlockFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tSCFinishUnlockFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
    }
    static TSCFinishUnlock() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TCSReceive : pb::GeneratedMessageLite<TCSReceive, TCSReceive.Builder> {
    private TCSReceive() { }
    private static readonly TCSReceive defaultInstance = new TCSReceive().MakeReadOnly();
    private static readonly string[] _tCSReceiveFieldNames = new string[] { "buildingId" };
    private static readonly uint[] _tCSReceiveFieldTags = new uint[] { 8 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSReceive DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TCSReceive DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TCSReceive ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tCSReceiveFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TCSReceive other = obj as TCSReceive;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSReceive ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSReceive ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSReceive ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSReceive ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSReceive ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSReceive ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSReceive ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSReceive ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSReceive ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSReceive ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TCSReceive MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TCSReceive prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TCSReceive, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TCSReceive cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TCSReceive result;
      
      private TCSReceive PrepareBuilder() {
        if (resultIsReadOnly) {
          TCSReceive original = result;
          result = new TCSReceive();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TCSReceive MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TCSReceive DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TCSReceive.DefaultInstance; }
      }
      
      public override TCSReceive BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TCSReceive) {
          return MergeFrom((TCSReceive) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TCSReceive other) {
        if (other == global::com.game.framework.protocol.TCSReceive.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tCSReceiveFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tCSReceiveFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
    }
    static TCSReceive() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TSCReceive : pb::GeneratedMessageLite<TSCReceive, TSCReceive.Builder> {
    private TSCReceive() { }
    private static readonly TSCReceive defaultInstance = new TSCReceive().MakeReadOnly();
    private static readonly string[] _tSCReceiveFieldNames = new string[] { "buildingId", "configId", "number" };
    private static readonly uint[] _tSCReceiveFieldTags = new uint[] { 8, 16, 24 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCReceive DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TSCReceive DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TSCReceive ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int ConfigIdFieldNumber = 2;
    private bool hasConfigId;
    private int configId_;
    public bool HasConfigId {
      get { return hasConfigId; }
    }
    public int ConfigId {
      get { return configId_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int NumberFieldNumber = 3;
    private bool hasNumber;
    private int number_;
    public bool HasNumber {
      get { return hasNumber; }
    }
    public int Number {
      get { return number_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tSCReceiveFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
      if (hasConfigId) {
        output.WriteInt32(2, field_names[1], ConfigId);
      }
      if (hasNumber) {
        output.WriteInt32(3, field_names[2], Number);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        if (hasConfigId) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, ConfigId);
        }
        if (hasNumber) {
          size += pb::CodedOutputStream.ComputeInt32Size(3, Number);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      if (hasConfigId) hash ^= configId_.GetHashCode();
      if (hasNumber) hash ^= number_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TSCReceive other = obj as TSCReceive;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      if (hasConfigId != other.hasConfigId || (hasConfigId && !configId_.Equals(other.configId_))) return false;
      if (hasNumber != other.hasNumber || (hasNumber && !number_.Equals(other.number_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCReceive ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCReceive ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCReceive ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCReceive ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCReceive ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCReceive ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCReceive ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCReceive ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCReceive ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCReceive ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TSCReceive MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TSCReceive prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TSCReceive, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TSCReceive cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TSCReceive result;
      
      private TSCReceive PrepareBuilder() {
        if (resultIsReadOnly) {
          TSCReceive original = result;
          result = new TSCReceive();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TSCReceive MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TSCReceive DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TSCReceive.DefaultInstance; }
      }
      
      public override TSCReceive BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TSCReceive) {
          return MergeFrom((TSCReceive) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TSCReceive other) {
        if (other == global::com.game.framework.protocol.TSCReceive.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        if (other.HasConfigId) {
          ConfigId = other.ConfigId;
        }
        if (other.HasNumber) {
          Number = other.Number;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tSCReceiveFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tSCReceiveFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
            case 16: {
              result.hasConfigId = input.ReadInt32(ref result.configId_);
              break;
            }
            case 24: {
              result.hasNumber = input.ReadInt32(ref result.number_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
      
      public bool HasConfigId {
        get { return result.hasConfigId; }
      }
      public int ConfigId {
        get { return result.ConfigId; }
        set { SetConfigId(value); }
      }
      public Builder SetConfigId(int value) {
        PrepareBuilder();
        result.hasConfigId = true;
        result.configId_ = value;
        return this;
      }
      public Builder ClearConfigId() {
        PrepareBuilder();
        result.hasConfigId = false;
        result.configId_ = 0;
        return this;
      }
      
      public bool HasNumber {
        get { return result.hasNumber; }
      }
      public int Number {
        get { return result.Number; }
        set { SetNumber(value); }
      }
      public Builder SetNumber(int value) {
        PrepareBuilder();
        result.hasNumber = true;
        result.number_ = value;
        return this;
      }
      public Builder ClearNumber() {
        PrepareBuilder();
        result.hasNumber = false;
        result.number_ = 0;
        return this;
      }
    }
    static TSCReceive() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TCSProcess : pb::GeneratedMessageLite<TCSProcess, TCSProcess.Builder> {
    private TCSProcess() { }
    private static readonly TCSProcess defaultInstance = new TCSProcess().MakeReadOnly();
    private static readonly string[] _tCSProcessFieldNames = new string[] { "buildingId", "number" };
    private static readonly uint[] _tCSProcessFieldTags = new uint[] { 8, 16 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSProcess DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TCSProcess DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TCSProcess ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int NumberFieldNumber = 2;
    private bool hasNumber;
    private int number_;
    public bool HasNumber {
      get { return hasNumber; }
    }
    public int Number {
      get { return number_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tCSProcessFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
      if (hasNumber) {
        output.WriteInt32(2, field_names[1], Number);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        if (hasNumber) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, Number);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      if (hasNumber) hash ^= number_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TCSProcess other = obj as TCSProcess;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      if (hasNumber != other.hasNumber || (hasNumber && !number_.Equals(other.number_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSProcess ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSProcess ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSProcess ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSProcess ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSProcess ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSProcess ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSProcess ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSProcess ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSProcess ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSProcess ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TCSProcess MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TCSProcess prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TCSProcess, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TCSProcess cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TCSProcess result;
      
      private TCSProcess PrepareBuilder() {
        if (resultIsReadOnly) {
          TCSProcess original = result;
          result = new TCSProcess();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TCSProcess MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TCSProcess DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TCSProcess.DefaultInstance; }
      }
      
      public override TCSProcess BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TCSProcess) {
          return MergeFrom((TCSProcess) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TCSProcess other) {
        if (other == global::com.game.framework.protocol.TCSProcess.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        if (other.HasNumber) {
          Number = other.Number;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tCSProcessFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tCSProcessFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
            case 16: {
              result.hasNumber = input.ReadInt32(ref result.number_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
      
      public bool HasNumber {
        get { return result.hasNumber; }
      }
      public int Number {
        get { return result.Number; }
        set { SetNumber(value); }
      }
      public Builder SetNumber(int value) {
        PrepareBuilder();
        result.hasNumber = true;
        result.number_ = value;
        return this;
      }
      public Builder ClearNumber() {
        PrepareBuilder();
        result.hasNumber = false;
        result.number_ = 0;
        return this;
      }
    }
    static TCSProcess() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TSCProcess : pb::GeneratedMessageLite<TSCProcess, TSCProcess.Builder> {
    private TSCProcess() { }
    private static readonly TSCProcess defaultInstance = new TSCProcess().MakeReadOnly();
    private static readonly string[] _tSCProcessFieldNames = new string[] { "buildingId", "finishTime", "number", "uid" };
    private static readonly uint[] _tSCProcessFieldTags = new uint[] { 8, 16, 32, 24 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCProcess DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TSCProcess DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TSCProcess ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int FinishTimeFieldNumber = 2;
    private bool hasFinishTime;
    private long finishTime_;
    public bool HasFinishTime {
      get { return hasFinishTime; }
    }
    public long FinishTime {
      get { return finishTime_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int UidFieldNumber = 3;
    private bool hasUid;
    private long uid_;
    public bool HasUid {
      get { return hasUid; }
    }
    public long Uid {
      get { return uid_; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int NumberFieldNumber = 4;
    private bool hasNumber;
    private int number_;
    public bool HasNumber {
      get { return hasNumber; }
    }
    public int Number {
      get { return number_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tSCProcessFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
      if (hasFinishTime) {
        output.WriteInt64(2, field_names[1], FinishTime);
      }
      if (hasUid) {
        output.WriteInt64(3, field_names[3], Uid);
      }
      if (hasNumber) {
        output.WriteInt32(4, field_names[2], Number);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        if (hasFinishTime) {
          size += pb::CodedOutputStream.ComputeInt64Size(2, FinishTime);
        }
        if (hasUid) {
          size += pb::CodedOutputStream.ComputeInt64Size(3, Uid);
        }
        if (hasNumber) {
          size += pb::CodedOutputStream.ComputeInt32Size(4, Number);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      if (hasFinishTime) hash ^= finishTime_.GetHashCode();
      if (hasUid) hash ^= uid_.GetHashCode();
      if (hasNumber) hash ^= number_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TSCProcess other = obj as TSCProcess;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      if (hasFinishTime != other.hasFinishTime || (hasFinishTime && !finishTime_.Equals(other.finishTime_))) return false;
      if (hasUid != other.hasUid || (hasUid && !uid_.Equals(other.uid_))) return false;
      if (hasNumber != other.hasNumber || (hasNumber && !number_.Equals(other.number_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCProcess ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCProcess ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCProcess ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCProcess ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCProcess ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCProcess ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCProcess ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCProcess ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCProcess ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCProcess ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TSCProcess MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TSCProcess prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TSCProcess, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TSCProcess cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TSCProcess result;
      
      private TSCProcess PrepareBuilder() {
        if (resultIsReadOnly) {
          TSCProcess original = result;
          result = new TSCProcess();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TSCProcess MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TSCProcess DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TSCProcess.DefaultInstance; }
      }
      
      public override TSCProcess BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TSCProcess) {
          return MergeFrom((TSCProcess) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TSCProcess other) {
        if (other == global::com.game.framework.protocol.TSCProcess.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        if (other.HasFinishTime) {
          FinishTime = other.FinishTime;
        }
        if (other.HasUid) {
          Uid = other.Uid;
        }
        if (other.HasNumber) {
          Number = other.Number;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tSCProcessFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tSCProcessFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
            case 16: {
              result.hasFinishTime = input.ReadInt64(ref result.finishTime_);
              break;
            }
            case 24: {
              result.hasUid = input.ReadInt64(ref result.uid_);
              break;
            }
            case 32: {
              result.hasNumber = input.ReadInt32(ref result.number_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
      
      public bool HasFinishTime {
        get { return result.hasFinishTime; }
      }
      public long FinishTime {
        get { return result.FinishTime; }
        set { SetFinishTime(value); }
      }
      public Builder SetFinishTime(long value) {
        PrepareBuilder();
        result.hasFinishTime = true;
        result.finishTime_ = value;
        return this;
      }
      public Builder ClearFinishTime() {
        PrepareBuilder();
        result.hasFinishTime = false;
        result.finishTime_ = 0L;
        return this;
      }
      
      public bool HasUid {
        get { return result.hasUid; }
      }
      public long Uid {
        get { return result.Uid; }
        set { SetUid(value); }
      }
      public Builder SetUid(long value) {
        PrepareBuilder();
        result.hasUid = true;
        result.uid_ = value;
        return this;
      }
      public Builder ClearUid() {
        PrepareBuilder();
        result.hasUid = false;
        result.uid_ = 0L;
        return this;
      }
      
      public bool HasNumber {
        get { return result.hasNumber; }
      }
      public int Number {
        get { return result.Number; }
        set { SetNumber(value); }
      }
      public Builder SetNumber(int value) {
        PrepareBuilder();
        result.hasNumber = true;
        result.number_ = value;
        return this;
      }
      public Builder ClearNumber() {
        PrepareBuilder();
        result.hasNumber = false;
        result.number_ = 0;
        return this;
      }
    }
    static TSCProcess() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TCSInterruptProcess : pb::GeneratedMessageLite<TCSInterruptProcess, TCSInterruptProcess.Builder> {
    private TCSInterruptProcess() { }
    private static readonly TCSInterruptProcess defaultInstance = new TCSInterruptProcess().MakeReadOnly();
    private static readonly string[] _tCSInterruptProcessFieldNames = new string[] { "buildingId" };
    private static readonly uint[] _tCSInterruptProcessFieldTags = new uint[] { 8 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSInterruptProcess DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TCSInterruptProcess DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TCSInterruptProcess ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tCSInterruptProcessFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TCSInterruptProcess other = obj as TCSInterruptProcess;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSInterruptProcess ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSInterruptProcess ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSInterruptProcess ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSInterruptProcess ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSInterruptProcess ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSInterruptProcess ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSInterruptProcess ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSInterruptProcess ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSInterruptProcess ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TCSInterruptProcess ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TCSInterruptProcess MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TCSInterruptProcess prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TCSInterruptProcess, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TCSInterruptProcess cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TCSInterruptProcess result;
      
      private TCSInterruptProcess PrepareBuilder() {
        if (resultIsReadOnly) {
          TCSInterruptProcess original = result;
          result = new TCSInterruptProcess();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TCSInterruptProcess MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TCSInterruptProcess DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TCSInterruptProcess.DefaultInstance; }
      }
      
      public override TCSInterruptProcess BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TCSInterruptProcess) {
          return MergeFrom((TCSInterruptProcess) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TCSInterruptProcess other) {
        if (other == global::com.game.framework.protocol.TCSInterruptProcess.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tCSInterruptProcessFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tCSInterruptProcessFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
    }
    static TCSInterruptProcess() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  public sealed partial class TSCInterruptProcess : pb::GeneratedMessageLite<TSCInterruptProcess, TSCInterruptProcess.Builder> {
    private TSCInterruptProcess() { }
    private static readonly TSCInterruptProcess defaultInstance = new TSCInterruptProcess().MakeReadOnly();
    private static readonly string[] _tSCInterruptProcessFieldNames = new string[] { "buildingId" };
    private static readonly uint[] _tSCInterruptProcessFieldTags = new uint[] { 8 };
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCInterruptProcess DefaultInstance {
      get { return defaultInstance; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override TSCInterruptProcess DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TSCInterruptProcess ThisMessage {
      get { return this; }
    }
    
    #if UNITY_EDITOR
    [pb.FieldNumber]
    #endif//
    public const int BuildingIdFieldNumber = 1;
    private bool hasBuildingId;
    private long buildingId_;
    public bool HasBuildingId {
      get { return hasBuildingId; }
    }
    public long BuildingId {
      get { return buildingId_; }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tSCInterruptProcessFieldNames;
      if (hasBuildingId) {
        output.WriteInt64(1, field_names[0], BuildingId);
      }
    }
    
    private int memoizedSerializedSize = -1;
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBuildingId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, BuildingId);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasBuildingId) hash ^= buildingId_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TSCInterruptProcess other = obj as TSCInterruptProcess;
      if (other == null) return false;
      if (hasBuildingId != other.hasBuildingId || (hasBuildingId && !buildingId_.Equals(other.buildingId_))) return false;
      return true;
    }
    
    #endregion
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCInterruptProcess ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCInterruptProcess ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCInterruptProcess ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCInterruptProcess ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCInterruptProcess ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCInterruptProcess ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCInterruptProcess ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCInterruptProcess ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCInterruptProcess ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static TSCInterruptProcess ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TSCInterruptProcess MakeReadOnly() {
      return this;
    }
    
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder ToBuilder() { return CreateBuilder(this); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public override Builder CreateBuilderForType() { return new Builder(); }
    #if UNITY_EDITOR
     [pb.FieldNumber] 
     #endif//
    public static Builder CreateBuilder(TSCInterruptProcess prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite<TSCInterruptProcess, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TSCInterruptProcess cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TSCInterruptProcess result;
      
      private TSCInterruptProcess PrepareBuilder() {
        if (resultIsReadOnly) {
          TSCInterruptProcess original = result;
          result = new TSCInterruptProcess();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TSCInterruptProcess MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TSCInterruptProcess DefaultInstanceForType {
        get { return global::com.game.framework.protocol.TSCInterruptProcess.DefaultInstance; }
      }
      
      public override TSCInterruptProcess BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TSCInterruptProcess) {
          return MergeFrom((TSCInterruptProcess) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TSCInterruptProcess other) {
        if (other == global::com.game.framework.protocol.TSCInterruptProcess.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBuildingId) {
          BuildingId = other.BuildingId;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tSCInterruptProcessFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tSCInterruptProcessFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBuildingId = input.ReadInt64(ref result.buildingId_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasBuildingId {
        get { return result.hasBuildingId; }
      }
      public long BuildingId {
        get { return result.BuildingId; }
        set { SetBuildingId(value); }
      }
      public Builder SetBuildingId(long value) {
        PrepareBuilder();
        result.hasBuildingId = true;
        result.buildingId_ = value;
        return this;
      }
      public Builder ClearBuildingId() {
        PrepareBuilder();
        result.hasBuildingId = false;
        result.buildingId_ = 0L;
        return this;
      }
    }
    static TSCInterruptProcess() {
      object.ReferenceEquals(global::com.game.framework.protocol.Scene.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
#pragma warning restore
